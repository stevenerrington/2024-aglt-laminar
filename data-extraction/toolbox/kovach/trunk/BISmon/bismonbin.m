classdef bismonbin < handle
 
% Class for the interface with the coviden BIS monitor in binary mode
%
% Usage:
%
%  1. Create the object:
%   	bisobj = bismonbin
%
%  2. Connect to the device
%       bsobj.connect()
%
%  3. Start recording data to a file         
%      bisobj.recordEEG
%
% Data sampled at 128 Hz are recorded in ASCII format with a separate
% column for each channel. The start of each frame (row starting with FRAME) 
% contains a sequence number, number of channels and timestamp. **NOTE**: The 
% the timestamp indicates when the frame was written to file, not when it 
% was recorded, which may be deviate from the latter by a large amount. Use 
% the sequence number to infer recording time.
%
% Processed data retrieved every 1 sec are interleaved with the raw data along
% any error messages generated by the device.
%
% 
% C Kovach 2017

    properties
        serial_port = 'COM1';  %Connection port
%         protocol = 'BIN'; 
        recordFile = '';    %  File to which data are recorded in ASCII form
        lpt_obj             % Object for a parallel port
        send_lpt_codes = true; % Whether to send event codes on a parallel port       
        DataFile = '';  % File to which to record raw binary data for later parsing.
        pollingPeriod=.25;   % Period with which the timeer checks for new packets in sec
        packets = [];       % Current data packets.
        headerFile = 'bismon.h'; % C header file in which the data structures are defined
                                 % This must be present with the script.
        processed_data_labels='';
        delim =', '
    end

    properties (SetAccess = private)      
        serial_obj  % Serial port object 
        buffer =[]
        fid
        numRecords=0;
        timer_obj = timer;
        bufferSize = 32768;
       nowrite=false;
       noread=false;
       structs; % Data structures identified in the header file
       defines
       recordingEEG = false; 
       packetsTransmitted=0;
       packetsFailed=0;
       packetsLost=0;
       msg_seq=0;
       
    end
    methods

        function me = bismonbin
            
            pk = struct('packet_seq',[],'directive',[],'routeid',[],'messageID','','messageIdCode',[],'msg_seq',[],'appdata',[]);
           
            me.structs = me.readDataStructures;
            me.packets = pk([]);
%             connect(me);

        end

        function connect(me)

%             switch lower(me.protocol)
% %                 case 'ascii'
% %                     BaudRate = 9600;
% %                     DataBits = 8;
% %                     StopBits = 1;
% %                     Parity = 'none'; 
%                 case {'binary','bin'}
                    BaudRate = 57600;
                    DataBits = 8;
                    StopBits = 1;
                    Parity = 'none';
%                     MinBytesAvail = 10;
%                 otherwise
%                     error('Protocol must be  BINARY')
% 
%             end
            if me.send_lpt_codes
                   me.lpt_obj = initializeLPT;
            end
            me.serial_obj = serial(me.serial_port,'BaudRate',BaudRate,'DataBits',DataBits,...
                                  'StopBits',StopBits,'Parity',Parity,'ReadAsyncMode','Continuous',...
                                 'inputBufferSize',me.bufferSize,'BytesAvailableFcnCount',me.bufferSize,...
                                 'BytesAvailableFcnMode','terminator');
           try           
               fopen(me.serial_obj); 
           catch err
               warning(err.message)
               fprintf('\nTry running:\n\t\tdelete(instrfind)\nand start again.\n');
           end
           pause(.1)
           me.flush;
           me.sendPacket(struct('messageID','SEND_PROCESSED_VARS_LABELS'));
           pause(1)
           p = me.readPackets;
%            while isempty(p(end).appdata)
%                me.sendPacket(struct('messageID','SEND_PROCESSED_VARS_LABELS'));
%                 p = me.readPackets;
%            end
          
          
           me.processed_data_labels = me.parseData(p(end));
%            me.isConnected = strcmp(get(me.serial_obj,'Status'),'open')
        end
        
        function recordRaw(me)
            if isempty(me.DataFile)
                [fn,pth] = uiputfile({'*.*'});
                me.DataFile = fullfile(pth,fn);
            end
            
            me.fid = fopen(me.DataFile,'a+');
            set(me.timer_obj,'TimerFcn',@(varargin)me.savePackets,'ExecutionMode','fixedRate','Period',me.pollingPeriod)
            start(me.timer_obj);
%            me.serial_obj.BytesAvailableFcn = @(varargin)me.collectPackets;
%            me.serial_obj.BytesAvailableFcn = @()fprintf('\nhonk');
        end
        
        function flush(me)
            p = me.readPackets;
            while ~isempty(p(end).directive)
                p = me.readPackets;
            end                
        end
        
        function collectPackets(me)
            
           me.packets = [me.packets,me.readPackets(true)];
            
        end

       %%%%%


        function outbin = create_packet(me,datas)
            outbin = [];
            
            yank = @(x)x(:);
            tobytes = @(x)uint8(yank([bitand(x(:),255),bitand(x(:),255*256)/256]'));
            
            for k = 1:length(datas)
                data = datas(k);
                  %Create the packet
                if isfield(data,'appdata')&&~isempty(data.appdata) && ~(ischar(data.appdata)||isa(data.appdata,'uint8')||isa(data.appdata,'uint16'))
                    error('Data must be an array of 8 bit chars or ints')
                end


                START_OF_PACKET= uint8([186; 171]) ; 

                 if isfield(data,'messageID') && ~isempty(data.messageID)
                     [msgid,msgdat,routeid] = me.MsgIDHash(data.messageID);
                 else
                     msgid = [];
                     msgdat=[];
                     routeid=0;
                 end

                if ~isfield(data,'appdata')|| isempty(data.appdata)
                    data.appdata = msgdat; %Set default value;
                end
                 if ~isfield(data,'packet_seq')|| isempty(data.packet_seq)
                    data.packet_seq = 0; %Set default value;
                end
                if ~isempty(data.appdata)
                     datacont = uint8(data.appdata);
%                     datacont = double(data.appdata);
%                     datacont(end+1:2*ceil(length(datacont/2)))=0;
%                     datacont = uint16((2.^((0:1)*8))*reshape(datacont,2,length(datacont)/2));
                else
                    datacont = uint8([]);
                end



                if ~isfield(data,'msg_seq')||isempty(data.msg_seq)
                    data.seqnum = 0;
                end
                if ~isfield(data,'directive')||isempty(data.directive)
                    data.directive = 1;
                end

                if ischar(data.directive)
                    data.directive = me.MsgIDHash(data.directive);
                end

                if ~isempty(msgid)
                    if ~isfield(data,'msg_seq')|| isempty(data.msg_seq)
                        data.msg_seq = 0; %Set default value;
                    end                
                    seqnum = uint16(data.msg_seq);
                    len = uint16(length(data.appdata));
                    msgid = [uint16(msgid);uint16(msgid./2^16)];
                    layer3head = tobytes([msgid; seqnum ;len]);
                    layer3 = [layer3head(:);datacont(:)]; 
                else
                    layer3 = [];
                end
                routeid = uint32(routeid);
                routing_data = [tobytes(routeid);tobytes(routeid/2^16)];
%                 if routeid>0
                    layer2 = cat(1,routing_data,layer3(:));
    %                 l2bytes = [bitand(layer2,255),bitand(layer2,255*256)/256]';
%                 else
%                     layer2=uint8([]);
%     %                 l2bytes=uint16(0);
%                 end
                nbytes = uint16(length(layer2));
                directive = uint16(data.directive);
                packseq = uint16(data.packet_seq);
                layer1head = [packseq;nbytes;directive];
                layer1middle = [tobytes(layer1head);layer2(:)];
              
                checksum = tobytes(sum(uint16(layer1middle(:))));
                layer1 = cat(1,START_OF_PACKET,layer1middle,checksum);
                outbin =[outbin;layer1];
            end
        end
%%%%%
        function  sendPacket(me,packet)

            if isstruct(packet)
                packet = me.create_packet(packet);
            end
            fwrite(me.serial_obj,packet,'uint8');

%             resp = fread(me.serial_obj,max(ceil(me.serial_obj.BytesAvailable/2),5),'uint16');

        end
        %%%%
        function packets = readPackets(me,acknowledge)
            %%% Read data from serial i/o port and parse
          
            if nargin < 2
                acknowledge = false;
            end
            pause = .001;
            
            navail = me.serial_obj.BytesAvailable;
            packets = [];
            data=[];
            if ~me.noread
                  me.noread = true;
                 try
                    while navail>0 
                       newdata = fread(me.serial_obj,navail,'uint8');
                       data = [data;newdata(:)];
                       tic, while toc<pause,end
                       navail = me.serial_obj.BytesAvailable;
                
        %             else
        %                warning('No bytes available')
        %                packets = [];
                    end

                    [packets,me.buffer] =me.parsePackets([me.buffer;data]);
                    if acknowledge && strcmp(packets(end).directive,'L1_DATA_PACKET')
                        me.sendPacket(struct('directive','L1_ACK_PACKET','msg_seq',packets(end).msg_seq));
                    end
                end
                 me.noread=false;
            end
        end
        
         function savePackets(me)%,acknowledge)
            %%% Read data from serial i/o port and parse
          
%             if nargin < 2
%                 acknowledge = true;
%             end
            pause = .002;
            
            navail = me.serial_obj.BytesAvailable;
            if ~me.noread && ~me.nowrite
                me.noread=true;
                me.nowrite=false;
                try                
                    while navail>0 

                        fwrite(me.fid,fread(me.serial_obj,navail,'uint8'));

        %                 if acknowledge && strcmp(packets(end).directive,'L1_DATA_PACKET')
        %                         me.sendPacket(struct('directive','L1_ACK_PACKET','msg_seq',packets(end).msg_seq));
        %                 end
                        tic, while toc<pause,end
                       navail = me.serial_obj.BytesAvailable;
                        me.nowrite=false;
        %             else
        %                warning('No bytes available')
        %                packets = [];
                    end
                end
                me.nowrite = false;
                me.noread=false;
                  
            end
         end
        
           function recordEEG(me)%,acknowledge)
            %%% Read data from serial i/o port and parse
          
%             if nargin < 2
%                 acknowledge = true;
%             end
               if ~isequal(me.serial_obj.status,'open')
                   me.connect;
               end

                if isempty(me.DataFile) || isempty(me.fid)|| me.fid <0 || isempty(fopen(me.fid))
                    [fn,pth] = uiputfile;
                    me.DataFile = fullfile(pth,fn);
                    me.fid = fopen(me.DataFile,'a+');
                end
                me.flush;%Flush packets
                me.buffer(:)=[];
                fprintf(me.fid,'\n##### STARTED AT %i (unix usec) #####\n',round((now-datenum('1/1/1970'))*24*3600*1e6));
               fprintf(me.fid,'\n\nPROCESSED_DATA_LABELS ');
               lbls=me.getPacketDataLabels(me.structs.processed_vars_and_spectra_msg);
               fprintf(me.fid,[me.delim,'%s'],lbls{:});
%                me.sendPacket(struct('messageID','SEND_PROCESSED_VARS_LABELS'));
                me.sendPacket(struct('messageID','SEND_PROCESSED_VARS'));
                me.sendPacket(struct('messageID','SEND_RAW_EEG'));
                me.sendPacket(struct('messageID','TURN_ON_ERROR_MSG'));
                me.recordingEEG = true;
                me.msg_seq=0;
                fprintf(me.fid,'\n');
                if isvalid(me.timer_obj)
                    stop(me.timer_obj);
                else
                    me.timer_obj = timer;
                end
                set(me.timer_obj,'TimerFcn',@(varargin)me.writeToFile,'ExecutionMode','FixedRate','ErrorFcn',@(varargin)me.stopEEG);
                start(me.timer_obj);
           end
        function stopEEG(me)%,acknowledge)
            %%% Stop eeg
            
           me.sendPacket(struct('messageID','STOP_RAW_EEG'));
            me.sendPacket(struct('messageID','STOP_PROCESSED_VARS'));
                me.sendPacket(struct('messageID','TURN_OFF_ERROR_MSG'));
            me.recordingEEG = false;
            stop(me.timer_obj);
            fprintf(me.fid,'\n\n##### STOPPED AT %i (unix usec) #####\n',round((now-datenum('1/1/1970'))*24*3600*1e6));
            fclose(me.fid);
         
            
        end
         function writeToFile(me,p)%,acknowledge)
            %%% Read data from serial i/o port and parse
          if nargin <2
            p = me.readPackets;%(false);
          end
            dataframe=false;
               
            for k = 1:length(p)
                appdata = p(k).appdata;
               if isempty(p(k).messageID)
                   continue
               end
               
               dataframe=false;
               switch p(k).messageID
                   case 'M_DATA_RAW'
                        nchan = [1 256]*single(appdata(1:2));
                        srate = [1 256]*single(appdata(3:4));
                        data = appdata(5:2:end)+256*appdata(6:2:end);
                        data = double(bitand(data,2^15-1))- double(bitand(data,2^15)); %%% Conversion to signed int from unsigned.
                        seqnum = p(k).msg_seq;
                        data=reshape(data,nchan,length(data)/nchan);
                        fprintf(me.fid,'\nFRAME%s%i%s%i%s%i%s%i%s',me.delim,seqnum,me.delim,nchan,me.delim,srate,me.delim,round((now-datenum('1/1/1970'))*24*3600*1e6));
                        dataframe=true;
                        fprintf(me.fid,['\nEEG',me.delim,'%i',me.delim,'%i',me.delim],data(:));
                        d = (p(k).msg_seq-me.msg_seq)-1;
                        if d>0 &&  me.msg_seq~=0                           
                            me.packetsLost = me.packetsLost + d ;
                        end
                        me.msg_seq=p(k).msg_seq;
                        
                       otherwise
                        
%                         dstruct = sprintf('%s_msg',lower(p(k).messageID(3:end)));
%                         data = appdata(1:2:end)+256*appdata(2:2:end);
%                         data = double(bitand(data,2^15-1))- double(bitand(data,2^15));
                        data = me.parseData(p(k))  ;  

                        fprintf(me.fid,'\n%s\t%s',deblank(p(k).messageID),sprintf(['%s',me.delim],data));
                         
                        
                      
               end
               
            end
            if me.send_lpt_codes && dataframe
                seqnum = me.msg_seq;
                me.lpt_obj.put(0);
                tic, while toc<.001,end
                me.lpt_obj.put(bitand(seqnum,255))
                tic, while toc<.001,end
                me.lpt_obj.put(0);
                tic, while toc<.001,end
                me.lpt_obj.put(bitand(seqnum,255*256)/256)
                tic, while toc<.001,end
                me.lpt_obj.put(0);
            end
         end
         
         %%%
         function [parseddata ,data,datastruct]= parseData(me,packet,dstruct)
             
             %%% Parse the  raw data into a usable format according to the
             %%% data structures specified in bismon.h
             
             if isstruct(packet)
                 data = packet.appdata;
                 [~,~,~,dstruct] = me.MsgIDHash(packet.messageID);
             else
                 data = packet;
             end
      
             if isempty(data)
                 return
             end
             parseddata = '';
             fldn = fieldnames(dstruct);
             
             char2uintk = @(x,k)2.^(8*(0:k-1))*reshape(x(:),k,length(x)/k); % convert uint8 to uintk
             uint2int = @(x,k)  bitand(int64(x),2^(8*k-1)-1)-bitand(int64(x),2^(8*k-1)); %convert uint to int             
             char2intk = @(x,k)uint2int(char2uintk(x,k),k); % convert to signed int
             
             for k = 1:length(fldn)
                 var = dstruct.(fldn{k});
                 if isstruct(var)
                    
                     for kk = 1:length(var)
%                          [newpars,data] = me.parsestruc(data,var(kk));
                        [newpars,data,datastruct.(fldn{k})(kk)] = me.parseData(data,var(kk));
                         parseddata =sprintf('%s%s%s',parseddata,me.delim,newpars);
                     end
                     
                 else
                     type = dstruct.(fldn{k}){1};
                     sz = dstruct.(fldn{k}){2};
                     numeric=true;
                     switch type
                         case {'short','unsigned short'}
                             n=2;
                             fmt = 'uint16';
                         case {'long','unsigned long'}
                             n=4;
                             fmt = 'uint32';
                         case {'signed short'}
                             n=-2;
                             fmt = 'int16';
                         case {'signed long'}
                             n=-4;
                             fmt = 'int32';
                         case {'char','unsigned char'}
                             n=1;
                             fmt = 'char';
                             numeric = false;
                       case {'signed char'}
                             n=-1;
                             fmt = 'int8';
                         otherwise
                             error('unrecognized format')
                     end
                     
             
                 dend = abs(n)*sz;
                 if numeric
                     if n>0
                         newpars = num2str(char2uintk(single(data(1:dend)),n));
                     elseif n<0
                         newpars = num2str(char2intk(single(data(1:dend)),-n));

                     end         
                 else
                      newpars = char(data(1:dend));
                 end
                    
                     if isempty(deblank(newpars))
                         newpars ='NA';
                     end
                     data(1:dend) = [];
                     parseddata =sprintf('%s%s%s',parseddata,me.delim,newpars);
                     datastruct.(fldn{k})=newpars;
                  end
   
             end
         end
        %%%%
        function [resp,data] = parsePackets(me,data)
           
            %%% Parser based on specifications described in
            %%% BIS_Serial_Port_Specifications_070-0017_Rev_1.10.pdf
            
           START_OF_PACKET= uint8([186, 171]) ;  %Code at start of packet
           
          
           %%% Assume first instance of this code is the start of the
           %%% packet
           start = find(data(1:end-1)== START_OF_PACKET(1) & data(2:end)== START_OF_PACKET(2),1);
        
           data = uint16(data);
           
           resp = struct('packet_seq',[],'directive',[],'routeid',[],'messageID','','messageIdCode',[],'msg_seq',[],'appdata',[]);
           indx = 1;
           go = length(data)>10 && ~isempty(start);
           nbad = 0;
           lastfailed = false;
           while go
                
                 if length(data)<7 || isempty(start)
                     go=false;
                     continue
                 end
                 
                 backdata = data(1:start);
                  data(1:start+1) = [];
                 nbytes=data(3)+data(4)*256;
                 msgd = data(5)+data(6)*256;
                 
                 
                 if nbytes+8>length(data)
%                      go=false;
                      nbad = nbad+1;
                    start = find(data(1:end-1)== START_OF_PACKET(1) & data(2:end)== START_OF_PACKET(2),1);
        
                     continue
                 end
                 
                 optdata = data(6+(1:nbytes));
                 their_checksum = data(7 + nbytes)+256*data(8 + nbytes);
                 my_checksum = sum(data(1:6+nbytes));
                 checksum_bad = their_checksum~=my_checksum ;
                 if checksum_bad
                     warning('Bad checksum')
                     nbad = nbad+1;
                     start = find(data(1:end-1)== START_OF_PACKET(1) & data(2:end)== START_OF_PACKET(2),1);
                     lastfailed = true;
                     me.packetsFailed = me.packetsFailed+1;
                            continue                     
                 end
                 me.packetsTransmitted = me.packetsTransmitted+1;
                 lastfailed = false;
                 resp(indx).packet_seq=data(1)+data(2)*256;
                resp(indx).directive=me.MsgIDHash(msgd);
              
                 if isempty(optdata)
                     optdata = [0 0 0 0]';
                 end
                 resp(indx).routeid =  2.^(8*(0:3))*double(optdata(1:4)); 
                 appdata = optdata(5:end);
                 if ~isempty(appdata)
                     msgid = 2.^(8*(0:3))*double(appdata(1:4));
                     resp(indx).messageIdCode = msgid;
                     resp(indx).messageID =  me.MsgIDHash( msgid );
                     resp(indx).msg_seq=appdata(5)+256*appdata(6);
%                       len=appdata(7)+256*appdata(8);
%                      length=appdata(4);
                     resp(indx).appdata = appdata(9:end);
                 end
                data(1 : 8 + nbytes) = [];
                if length(data)< 2
                    go = false;
                else
                    start = find(data(1:end-1)== START_OF_PACKET(1) & data(2:end)== START_OF_PACKET(2),1);
                    go = ~isempty(start);
                    indx = indx+1;
                end
           end
           
           if lastfailed
               data = [databack;data]; %Avoid discarding an incomplete packet.
           end

        end
        
        function labels = getPacketDataLabels(me,packet)
            
            if isfield(packet,'messageID')
                [~,~,~,dstruc]=me.MsgIDHash(packet.messageID);
            else
                dstruc = packet;
            end
            
            
            fns = fieldnames(dstruc);
            labels={};
            for kk = 1:length(dstruc)
            for k = 1:length(fns)
                if isstruct(dstruc(kk).(fns{k}))
                    labels =[labels,me.getPacketDataLabels(dstruc(kk).(fns{k}))];
                else
                    labels =[labels,fns(k)];
                end
            end
            end            
        end


        function delete(me)
%             disconnect(me); 
            delete(me.timer_obj);
            delete(me.serial_obj);
            if ~isempty(me.fid) && me.fid>0 &&~isempty(fopen(me.fid))
                fclose(me.fid)
            end
        end
        
        
    %%%%%%% Function to read data structure from header file

    function dat = readDataStructures(me,re,indx0)


        if nargin < 2 || isempty(re)

            fid = fopen(me.headerFile,'r');

            txt = fread(fid,'uchar=>char')';
            fclose(fid);

            txt = regexprep(txt,'[\xD\xA]','\n');
            txt = regexprep(txt,'#','\n#');
             txt = regexprep(txt,';',';\n');
            re = regexprep(txt,'/\*.*?\*/','');

        %      re = regexprep(re,'\\\n','');
             re = regexprep(re,'//[^\n]*','');
             defnblock = regexp(re,'#define[^\n]*\n','match'); 
             defnblock=[defnblock{:}];
             re= regexprep(re,'#define[^\n]*','');
        %      defn = regexp(defnblock,'#define\s+(\w+)\s+([\dx\.]+[a-f]*)','tokens'); 
             defn = regexp(defnblock,'#define\s+(\w+)\s+([^\n]*)','tokens'); 
        %      defnblock = regexprep(defnblock,'#define\s+\w+\s[\dx\.]+[a-f]*',''); 
             defn = cat(1,defn{:});
             for k = 1:size(defn,1)
        %           re = regexprep(re,['#define\s+',defn{k,1},'\s+\d+\n'],'');

                   defn(:,2)= regexprep(defn(:,2),['([^\w]\(*)',defn{k,1},'(\)*[^\w\n])'],['$1',deblank(defn{k,2}),'$2']);
             end
             for k = 1:size(defn,1)
                 hval = regexp(defn{k,2},'0x([\da-f]+)','tokens');
                 for kk = 1:length(hval)
                    defn{k,2} =  regexprep(defn{k,2},['0x',hval{kk}],num2str(hex2dec(hval{kk})));
                 end
                 try
                  defn{k,2} = num2str(eval(deblank(defn{k,2})));
                 end
             end

        %     defn(:,2) = regexprep(defn(:,2),'0x([\da-f]*)','(??hex2dec($1))')

             for k = 1:length(defn)
        %           re = regexprep(re,['#define\s+',defn{k,1},'\s+\d+\n'],'');
                  re = regexprep(re,['([^\w]\(*)',defn{k,1},'(\)*[^\w])'],['$1',defn{k,2},'$2']);
             end
             re = regexprep(re,'#[^\n]*','');
             re = regexprep(re,'BIS MONITOR SERIAL[^\n]*','');
             re = regexprep(re,'A-\d*[^\n]*','');

            re = regexp(re,'[\n;]*\s*struct\s*(\w*)[\n\s]*{([^}]*)}','tokens');

            re = cat(1,re{:});
            indx0=1:size(re,1);
            defn = defn';
            me.defines = struct(defn{:});
        end
        strnames = re(:,1);

        for k = indx0

            re2 = regexp(re{k,2},'(\w+)\s*([\[\]\w]+)\s*([^;]*)','tokens');
            supername = re{k,1};
            for kk = 1:length(re2)

               sign ={}; 
              type=re2{kk}{1};
              name = re2{kk}{2};
              if strcmp(type,'struct')

                   sz=regexp(re2{kk}{3},'(\[\w*\]);*','match','once');
                   if ~isempty(sz)
                         name = regexprep(re2{kk}{2},['\',regexprep(sz,'\]','\\]')],'');
                         sz = str2num(sz);
                   else
                       sz=1;
                   end
                       indx = find(strcmp(name,strnames));              
                       newstr=  repmat(me.readDataStructures(re,indx),1,sz);
                      dat.(supername).(name) = [newstr.(name)];

              else
        %           sz=1;
                   if strcmp(type,'signed') || strcmp(type,'unsigned')

                       sign = {type};
                             type=re2{kk}{2};

                             name =deblank(regexprep(re2{kk}{3},';',''));

                   else
                         name = deblank(regexprep(re2{kk}{2},';',''));
                   end               
                    switch type
                             case 'long' 
                                 nbytes = 4;
                             case 'short'
                                 nbytes = 2;
                             otherwise
                                nbytes = 1;
                         end    
                     sz=regexp(name,'\[\w*\]','match');
                     if isempty(sz)
                         sz=1;
                     else
                        sz=regexprep([sz{:}],'\]\[',',');
                        name = regexprep(name,'\[.*\]','');
                         sz = str2num(sz);                     
                     end

                     dat.(supername).(name){1} = [sprintf('%s ',sign{:}),type];
                     dat.(supername).(name){2}= prod(sz);
                     dat.(supername).(name){3} = prod(sz)*nbytes;
              end
            end
        end
    end



%%%%
     function [msgid,msgdat,routeid,dstruct] = MsgIDHash(me,code)

     % Hash table to convert messages from and to codes. 
             msgdat = int8([]); %% Default data
             msgid = 0;routeid=0;
             dstruct=struct('data',{{'char',4,0}});

         switch upper(code)

             %%%%%% Packet type %%%%%%%%

            case {1,'L1_DATA_PACKET'}
            msgstr='L1_DATA_PACKET';
                msgid=1;                        
                routeid = [];
            case {2,'L1_ACK_PACKET'}
            msgstr='L1_ACK_PACKET';
                msgid=2;                        
                routeid = [];
            case {3,'L1_NAK_PACKET'}
            msgstr='L1_NAK_PACKET';
                msgid=3;                        
                routeid = [];

            %%%%%%% Messages to the device%%%%%%%

            case {111,'SEND_RAW_EEG'}
            msgstr='SEND_RAW_EEG';
                msgid=111;% Request Raw EEG data . Data are transmitted 8 packets/sec, with two or four channels of interleaved EEG data.
                msgdat = [128 ; 0]; %Default sampling rate. Set to [128; 0] for 128 and [0;1] for 256
                routeid = 4;
            case {112,'STOP_RAW_EEG'}
            msgstr='STOP_RAW_EEG';
                msgid= 112;% Stop sending raw EEG     
                  routeid = 4;
            case {115,'SEND_PROCESSED_VARS'}
            msgstr='SEND_PROCESSED_VARS';
                msgid= 115;% Send Processed Variables
                msgdat = int8(1);% Default Send spectrum
                  routeid = 4;
            case {116,'STOP_PROCESSED_VARS'}
            msgstr='STOP_PROCESSED_VARS';
                msgid= 116;% Stop sending Processed Variables
                  routeid = 4;
            case {1000,'TURN_ON_IMPED_MSG'}
                msgstr='TURN_ON_IMPED_MSG';
                msgid= 1000;% Starts sending impedance records once per second during Sensor Check and Ground Check.
                  routeid = 6;
            case {1001,'TURN_OFF_IMPED_MSG'}
                msgstr='TURN_OFF_IMPED_MSG';
                msgid= 1001;% Stops sending impedance records
                routeid = 6;
            case {1002,'TURN_ON_ERROR_MSG'}
               msgstr='TURN_ON_ERROR_MSG';
               msgid= 1002;% Starts sending error records (when errors occur).
                routeid = 6;
            case {1003,'TURN_OFF_ERROR_MSG'}
                msgstr='TURN_OFF_ERROR_MSG';
                msgid= 1003;% Stops sending error records
                routeid = 6;
            case {1004,'SEND_REVISION_INFO'}
                msgstr='SEND_REVISION_INFO';
                msgid= 1004;% Request to send revision information
                routeid = 6;
            case {133,'SEND_PROCESSED_VARS_LABELS'}
                msgstr='SEND_PROCESSED_VARS_LABELS';
                msgid= 133;% Sends the variable label header record
                routeid = 4;
            case {1006,'SEND_EEG_SNIPPET'}
                msgstr='SEND_EEG_SNIPPET';
                msgid= 1006;% Starts sending EEG snippet data (A-2000 only)
                routeid = 9;
            case {1007,'SEND_NEXT_EEG_SNIPPET_PKT'}
               msgstr='SEND_NEXT_EEG_SNIPPET_PKT';
                msgid= 1007;% Send next EEG snipped data (A-2000 only)
                routeid = 9;
            case {1009,'SEND_BIS_HISTORY'}
               msgstr='SEND_BIS_HISTORY';
                msgid= 1009;% Start sending BIS History data (A-2000 only, Protocol Rev. 1.06 and higher)
                routeid = 10;
            case {1010,'SEND_NEXT_HISTORY_PKT'}
               msgstr='SEND_NEXT_HISTORY_PKT';
                msgid= 1010;% Send next BIS History data (A-2000 only, Protocol Rev. 1.06 and higher)
                 routeid = 10;
            case {1011,'SEND_NEXT_BIS_HISTORY_PKT'}
                msgstr='SEND_NEXT_BIS_HISTORY_PKT';
                msgid= 1011;% Send next big BIS History data (A-2000 only, Protocol Rev. 1.06 and higher)
                routeid = 10;
            case {1014,'TURN_ON_SEND_EVENT'}
               msgstr='TURN_ON_SEND_EVENT';
                msgid= 1014;% Starts transmission of event records (Protocol Rev. 1.07 and higher)
                routeid =6;
            case {1015,'TURN_OFF_SEND_EVENT'}
              msgstr='TURN_OFF_SEND_EVENT';
                msgid= 1015;% Stops transmission of event records (Protocol Rev. 1.07 and higher)
                routeid = 6;
            case {1019,'SEND_EXTRA_VARIABLES'}
               msgstr='SEND_EXTRA_VARIABLES';
                msgid= 1019;% Starts transmitting extra variables (including Burst Count) in the processed variables messages and processed variables labels messages (Protocol Rev. 1.08 and higher)
                routeid = 5;
            case {1020,'STOP_EXTRA_VARIABLES'}
                msgstr='STOP_EXTRA_VARIABLES';
                msgid= 1020;% Stops transmission of extra variables (Protocol Rev. 1.08 and higher)
                routeid =5;
            case {1025,'SEND_PROCESSED_VARS_4B'}
               msgstr='SEND_PROCESSED_VARS_4B';
                msgid= 1025;% Enable Bilateral Processed Variables Packets and other 4-channel messages (Protocol Rev. 1.09 ? ?VISTA Binary?)
                 msgdat = int8(1);% Default Send spectrum
                 routeid = 4;
            case {1026,'SEND_PROCESSED_VARS_LABELS_4B'}
                msgstr='SEND_PROCESSED_VARS_LABELS_4B';
                    msgid= 1026;% Sends Bilateral variable
                    routeid = 4;

            %%%%%% Messages from the device%%%%%

            case {'M_DATA_RAW',50}% Raw EEG data, 8 packets per second If VISTA Legacy Binary Mode is selected and a bilateral sensor is connected, VISTA will send a 2 channel EEG message but the data will be invalid. To get raw EEG data for a Bilateral Sensor, use the VISTA Binary Mode
                      msgstr='M_DATA_RAW';   msgid = 50;
                         dstruct=struct('data',{{'signed short',4,0}});
             case {'M_PROCESSED_VARS',52}%  Processed Variables once per second
                      dstruct = me.structs.processed_vars_msg;
             case {'M_PROCESSED_VARS_AND_SPECTRA',53}%  Processed Variables and Spectra once per second
                      msgstr='M_PROCESSED_VARS_AND_SPECTRA';   msgid = 53;
                       dstruct = me.structs.processed_vars_and_spectra_msg;
             case {'SER_IMPED_MSG',1100}% Impedance values from Sensor Check or Continuous Ground Check
                      msgstr='SER_IMPED_MSG';   msgid = 1100;                  
             case {'SER_ERROR_MSG',1101}% Error Messages
                      msgstr='SER_ERROR_MSG';   msgid = 1101;
             case {'SER_REVISION_INFO',1102}% Software / System Revision Info
                      msgstr='SER_REVISION_INFO';   msgid = 1102;
                      dstruct=me.structs.revision_info_msg;
             case {'M_PROCESSED_VARS_LABELS',63}% Labels
                      msgstr='M_PROCESSED_VARS_LABELS';   msgid = 63;
                       dstruct=me.structs.be_trend_variables_labels;
             case {'SER_EEG_SNIPPET_HEADER',1104}% EEG Snippet Header (A-2000 Only)
                      msgstr='SER_EEG_SNIPPET_HEADER';   msgid = 1104;
                         dstruct=me.structs.snippet_info_msg;
             case {'SER_EEG_SNIPPET_RAW_DATA',1105}% EEG Snippet Data (A-2000 Only)
                      msgstr='SER_EEG_SNIPPET_RAW_DATA';   msgid = 1105;
                     struct('data',{{'signed short',4,0}})                 
             case {'SER_EEG_SNIPPET_PROCESSED_DATA',1106}% EEG Snippet Processed Variables (A-2000 Only)
                      msgstr='SER_EEG_SNIPPET_PROCESSED_DATA';   msgid = 1106;
                      dstruct=me.structs.snippet_processed_vars_msg;     
                      % OR dstruct=me.snippet_processed_extra_vars_msg
             case {'SER_NO_SNIPPET',1107}% No EEG Snippet Present (A-2000 Only)
                      msgstr='SER_NO_SNIPPET';   msgid = 1107;
             case {'SER_SNIPPET_CORRUPTED',1108}% EEG Snippet Error (A-2000 Only)
                      msgstr='SER_SNIPPET_CORRUPTED';   msgid = 1108;
             case {'SER_BIS_HISTORY_HEADER',1109}% BIS History Header (A-2000 Only, Protocol Rev. 1.06 and higher)
                      msgstr='SER_BIS_HISTORY_HEADER';   msgid = 1109;
                      dstruct=me.structs.history_info_msg;
             case {'SER_BIS_HISTORY_DATA',1110}% BIS History Data (A-2000 Only, Protocol Rev. 1.06 and higher)
                      msgstr='SER_BIS_HISTORY_DATA'; msgid = 1110;
                      dstruct= me.structs.history_data_msg;
             case {'SER_NO_HISTORY',1111}%  No BIS History (A-2000 Only, Protocol Rev. 1.06 and higher)
                      msgstr='SER_NO_HISTORY'; msgid = 1111;
             case {'SER_EVENT_MSG',1115}%  Indicates that an event was marked on the A-2000 or VISTA at the time specified (Protocol Rev. 1.07 and higher)
                      msgstr='SER_EVENT_MSG';   msgid = 1115;
             case {'M_PROCESSED_VARS_WITH_EXTRA_VARS',1120}% Processed Variables with Burst (Protocol Rev. 1.08 and higher)
                      msgstr='M_PROCESSED_VARS_WITH_EXTRA_VARS'; msgid = 1120;
                       dstruct= me.structs.processed_vars_with_extra_vars_msg;
             case {'M_PROCESSED_VARS_AND_SPECTRA_WITH_EXTRA_VAR',1121}% Processed Variables with Burst and Spectra (Protocol Rev. 1.08 and
                       msgstr='M_PROCESSED_VARS_AND_SPECTRA_WITH_EXTRA_VAR'; msgid = 1121;
                       dstruct= me.structs.processed_vars_and_spectra_with_extra_vars_msg;
             case {'M_PROCESSED_VARS_4B',1122}
                 msgstr='M_PROCESSED_VARS_4B'; msgid = 1122;
                        dstruct = me.structsprocessed_vars_msg_4b;
             case {'M_PROCESSED_VARS_4B_AND_SPECTRA',1123}
                      msgstr='M_PROCESSED_VARS_4B_AND_SPECTRA'; msgid = 1123;
                       dstruct = me.structs.processed_vars_and_spectra_msg_4B;
            case {'M_PROCESSED_VARS_LABELS_4B',1124}
                      msgstr='M_PROCESSED_VARS_LABELS_4B'; msgid = 1124;
                      dstruct = me.structs.be_bilateral_trend_variables_labels;
             otherwise 
                 msgstr='UNKNOWN'; 
                  warning('Unrecognized message ID %s',code)
         end

    %      msgid = uint16([bitand(msgid,255);bitand(msgid,255*256)/256]);
         if isnumeric(code)
             msgid = msgstr;
         end
     end
    end
end